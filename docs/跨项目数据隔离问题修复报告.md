# 跨项目数据隔离问题修复报告

## 🐛 问题描述

### 用户反馈的问题
用户在使用 PandaCoder 插件时发现：
- 在项目 A 中启动 SQL Monitor 和 ES DSL Monitor 监控服务
- 监控的日志正常显示在项目 A 的工具窗口中
- 打开一个新的 IDEA 窗口，打开项目 B
- **问题**：项目 A 的监控日志出现在了项目 B 的工具窗口中！

这是一个严重的**跨项目数据串扰**问题。

---

## 🔍 问题根因分析

### 1. 服务注册级别检查 ✅
首先检查了服务的注册级别，发现所有监控服务都**正确注册为 `projectService`**：

```xml
<!-- plugin.xml -->
<projectService serviceImplementation="com.shuyixiao.sql.service.SqlRecordService"/>
<projectService serviceImplementation="com.shuyixiao.sql.service.SqlMonitoringService"/>
<projectService serviceImplementation="com.shuyixiao.esdsl.service.EsDslRecordService"/>
<projectService serviceImplementation="com.shuyixiao.esdsl.service.EsDslMonitoringService"/>
<projectService serviceImplementation="com.shuyixiao.bugrecorder.service.ConsoleMonitoringService"/>
```

✅ 服务级别没有问题，每个项目都有独立的服务实例。

### 2. 数据存储机制检查 ✅
检查了数据存储位置，发现每个项目的数据都存储在各自的 `.idea` 目录下：

```java
// SqlRecordService.java
String projectPath = project.getBasePath();
File ideaDir = new File(projectPath, ".idea");
this.storageFile = new File(ideaDir, STORAGE_FILE);
```

✅ 数据存储隔离正确，每个项目有独立的数据文件。

### 3. 监听器注册机制检查 ❌ **发现问题！**

问题出在 `setupExecutionListener()` 方法中：

```java
// 问题代码
private void setupExecutionListener() {
    ApplicationManager.getApplication().getMessageBus()
            .connect(project)
            .subscribe(ExecutionManager.EXECUTION_TOPIC, new ExecutionListener() {
                @Override
                public void processStarted(@NotNull String executorId, 
                                         @NotNull ExecutionEnvironment env,
                                         @NotNull ProcessHandler handler) {
                    // ❌ 没有检查 env.getProject() 是否是当前项目！
                    ApplicationManager.getApplication().invokeLater(() -> {
                        attachListener(handler);
                    });
                }
            });
}
```

**问题分析**：
1. `ExecutionManager.EXECUTION_TOPIC` 是一个**应用级别的消息总线主题**
2. 虽然使用了 `.connect(project)` 来限定连接的生命周期
3. 但是 `EXECUTION_TOPIC` 会接收**所有项目**的执行事件
4. **关键缺陷**：`processStarted()` 方法中没有检查 `ExecutionEnvironment` 是否属于当前项目
5. 导致项目 A 的监控服务会监听到项目 B 的进程启动事件
6. 从而将项目 B 的日志记录到项目 A 的数据中

---

## ✅ 修复方案

### 修复原则
在所有 `ExecutionListener` 的回调方法中，添加**项目归属检查**：

```java
if (env.getProject() != project) {
    return; // 忽略其他项目的事件
}
```

### 修复的文件列表

#### 1. SQL Monitor 监控服务
**文件**: `src/main/java/com/shuyixiao/sql/service/SqlMonitoringService.java`

**修复内容**:
```java
@Override
public void processStarted(@NotNull String executorId, @NotNull ExecutionEnvironment env,
                           @NotNull ProcessHandler handler) {
    // ✅ 关键修复：只处理当前项目的进程，避免跨项目数据串扰
    if (env.getProject() != project) {
        LOG.debug("[SQL Monitor] 忽略其他项目的进程: " + env.getProject().getName());
        return;
    }
    
    ApplicationManager.getApplication().invokeLater(() -> {
        LOG.info("[SQL Monitor] 为当前项目附加监听器: " + project.getName());
        attachListener(handler);
    });
}

@Override
public void processTerminated(@NotNull String executorId, @NotNull ExecutionEnvironment env,
                              @NotNull ProcessHandler handler, int exitCode) {
    // ✅ 关键修复：只处理当前项目的进程
    if (env.getProject() != project) {
        return;
    }
    
    removeListener(handler);
}
```

#### 2. ES DSL Monitor 监控服务
**文件**: `src/main/java/com/shuyixiao/esdsl/service/EsDslMonitoringService.java`

**修复内容**: 与 SQL Monitor 相同的修复逻辑

#### 3. Bug Recorder 监控服务
**文件**: `src/main/java/com/shuyixiao/bugrecorder/service/ConsoleMonitoringService.java`

**修复内容**: 与 SQL Monitor 相同的修复逻辑

#### 4. Enhanced Bug Recorder 执行监听器
**文件**: `src/main/java/com/shuyixiao/bugrecorder/enhanced/EnhancedExecutionListener.java`

**修复内容**:
```java
private void handleProcessStarted(@NotNull String executorId, @NotNull ExecutionEnvironment env,
                                 @NotNull ProcessHandler handler) {
    if (isDisposed.get() || !monitoringService.isMonitoringEnabled()) {
        return;
    }

    // ✅ 关键修复：只处理当前项目的进程，避免跨项目数据串扰
    if (env.getProject() != project) {
        LOG.debug("[Enhanced Bug Recorder] 忽略其他项目的进程: " + env.getProject().getName());
        return;
    }

    // ... 后续处理逻辑
}

private void handleProcessTerminating(@NotNull String executorId, @NotNull ExecutionEnvironment env,
                                    @NotNull ProcessHandler handler) {
    if (isDisposed.get()) {
        return;
    }

    // ✅ 关键修复：只处理当前项目的进程
    if (env.getProject() != project) {
        return;
    }

    // ... 清理逻辑
}

private void handleProcessTerminated(@NotNull String executorId, @NotNull ExecutionEnvironment env,
                                   @NotNull ProcessHandler handler, int exitCode) {
    if (isDisposed.get()) {
        return;
    }

    // ✅ 关键修复：只处理当前项目的进程
    if (env.getProject() != project) {
        return;
    }

    // ... 清理逻辑
}
```

---

## 📊 修复效果

### 修复前
```
项目 A (PandaCoder)
  ├─ 启动 Spring Boot 应用
  ├─ SQL Monitor 监听器附加到进程
  └─ 捕获 SQL 日志 ✅

项目 B (OtherProject)
  ├─ 打开新的 IDEA 窗口
  ├─ 启动 Spring Boot 应用
  ├─ ❌ 项目 A 的 SQL Monitor 也监听到了项目 B 的进程！
  └─ ❌ 项目 B 的 SQL 日志出现在项目 A 的工具窗口中
```

### 修复后
```
项目 A (PandaCoder)
  ├─ 启动 Spring Boot 应用
  ├─ SQL Monitor 监听器附加到进程
  └─ 捕获 SQL 日志 ✅

项目 B (OtherProject)
  ├─ 打开新的 IDEA 窗口
  ├─ 启动 Spring Boot 应用
  ├─ ✅ 项目 A 的 SQL Monitor 检测到这是其他项目的进程，忽略
  ├─ ✅ 项目 B 的 SQL Monitor 监听器附加到自己的进程
  └─ ✅ 项目 B 的 SQL 日志只出现在项目 B 的工具窗口中
```

---

## 🎯 验证方法

### 测试步骤
1. 在 IDEA 中打开项目 A，启动 SQL Monitor 和 ES DSL Monitor
2. 运行项目 A 的 Spring Boot 应用，确认日志正常显示
3. 打开新的 IDEA 窗口，打开项目 B
4. 运行项目 B 的 Spring Boot 应用
5. **验证**：
   - 项目 A 的工具窗口中不应该出现项目 B 的日志
   - 项目 B 的工具窗口中不应该出现项目 A 的日志
   - 每个项目的日志应该完全隔离

### 日志验证
修复后，在日志中可以看到类似的输出：

```
[SQL Monitor] 为当前项目附加监听器: PandaCoder
[SQL Monitor] 忽略其他项目的进程: OtherProject
```

---

## 📝 技术总结

### 关键知识点
1. **IntelliJ Platform 的消息总线机制**
   - `ExecutionManager.EXECUTION_TOPIC` 是应用级别的主题
   - 会广播所有项目的执行事件
   - 必须在监听器中手动过滤项目

2. **项目级别服务的正确使用**
   - 虽然服务是项目级别的，但监听的事件是应用级别的
   - 需要在事件处理中检查 `ExecutionEnvironment.getProject()`

3. **数据隔离的多层保障**
   - 服务级别：使用 `projectService` 而不是 `applicationService`
   - 数据存储：存储在项目的 `.idea` 目录下
   - 事件处理：在监听器中过滤项目归属

### 最佳实践
在订阅应用级别的消息总线主题时，**始终检查事件的项目归属**：

```java
ApplicationManager.getApplication().getMessageBus()
    .connect(project)
    .subscribe(SOME_APPLICATION_LEVEL_TOPIC, new SomeListener() {
        @Override
        public void onEvent(Event event) {
            // ✅ 最佳实践：检查项目归属
            if (event.getProject() != project) {
                return;
            }
            
            // 处理事件
        }
    });
```

---

## ✅ 修复完成

**修复日期**: 2025-10-31

**影响范围**:
- SQL Monitor 监控服务 ✅
- ES DSL Monitor 监控服务 ✅
- Bug Recorder 监控服务 ✅
- Enhanced Bug Recorder 监控服务 ✅

**测试状态**: 待用户验证

**风险评估**: 低风险，仅添加了项目归属检查，不影响现有功能

