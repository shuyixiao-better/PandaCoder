# 活文档功能 - 当前状态说明

## ⚠️ 重要说明

**PandaCoder 是一个 IntelliJ IDEA 插件项目，不能使用 Spring Boot 和 Spring AI 框架。**

之前的实现方案基于 Spring AI，这是错误的。现在正在进行重构。

---

## 📊 当前状态

### ✅ 已完成（UI 部分）

1. **插件配置系统**
   - ✅ `LivingDocSettings.java` - 配置持久化服务
   - ✅ `LivingDocConfigurable.java` - 设置面板 UI
   - ✅ 支持 Gitee AI API Key 配置
   - ✅ 支持 Elasticsearch 连接配置

2. **工具窗口**
   - ✅ `LivingDocToolWindowFactory.java` - 工具窗口工厂
   - ✅ `LivingDocToolWindowPanel.java` - 工具窗口面板

3. **Actions 操作**
   - ✅ `IndexProjectAction.java` - 索引项目操作
   - ✅ `SearchDocAction.java` - 搜索文档操作
   - ✅ `ExportDocAction.java` - 导出文档操作

4. **plugin.xml 配置**
   - ✅ 注册了配置服务
   - ✅ 注册了设置面板
   - ✅ 注册了工具窗口
   - ✅ 注册了 Actions 菜单

5. **图标资源**
   - ✅ `livingdoc.svg` - 主图标
   - ✅ `search.svg` - 搜索图标
   - ✅ `export.svg` - 导出图标

### ❌ 已删除（Spring 相关）

以下文件因为依赖 Spring 框架而被删除：

1. **配置类**
   - ❌ `LivingDocProperties.java` - Spring 配置属性
   - ❌ `AiModelAutoConfiguration.java` - Spring AI 自动配置
   - ❌ `VectorStoreAutoConfiguration.java` - 向量存储自动配置

2. **AI 模型**
   - ❌ `GiteeAiChatModel.java` - Spring AI 适配器
   - ❌ `GiteeAiEmbeddingModel.java` - Spring AI 适配器

3. **核心服务**
   - ❌ `LivingDocRagService.java` - RAG 服务
   - ❌ `SpringBootAnalyzer.java` - 代码分析器

4. **Elasticsearch 实现**
   - ❌ `ElasticsearchVectorStore.java` - 旧版实现

5. **测试文件**
   - ❌ `GiteeAiIntegrationTest.java`
   - ❌ `RagServiceTest.java`

### ✅ 保留（核心架构）

1. **数据模型**
   - ✅ `VectorDocument.java` - 向量文档模型
   - ✅ `SearchResult.java` - 搜索结果模型
   - ✅ `VectorStore.java` - 向量存储接口
   - ✅ `ElasticsearchVectorStore_8_15.java` - ES 8.15 实现（需修复）

2. **分析器模型**
   - ✅ `ApiEndpoint.java` - API 端点模型
   - ✅ `Parameter.java` - 参数模型
   - ✅ `ResponseModel.java` - 响应模型
   - ✅ `ProjectDocumentation.java` - 项目文档模型
   - ✅ `EntityModel.java` - 实体模型

3. **依赖配置**
   - ✅ Elasticsearch 8.15 依赖
   - ✅ OkHttp 客户端依赖

---

## 🎯 重构方案

### 方案一：简化版（推荐）

**不使用 RAG 和 AI**，只实现基础的文档生成和管理：

1. **代码分析**
   - 使用 IntelliJ PSI API 分析 Java 代码
   - 提取 API 接口信息（Controller、Service 等）
   - 生成 Markdown/HTML 文档

2. **文档管理**
   - 保存到本地文件
   - 支持导出多种格式
   - 支持搜索（基于文件内容）

3. **优点**
   - ✅ 无需外部依赖（AI、ES）
   - ✅ 实现简单，稳定可靠
   - ✅ 适合 IDEA 插件

### 方案二：轻量级 RAG

**使用简单的向量搜索**，不依赖 Spring AI：

1. **AI 集成**
   - 直接调用 Gitee AI HTTP API（使用 OkHttp）
   - 自己实现 Embedding 和 Chat 逻辑

2. **向量存储**
   - 使用 Elasticsearch 8.15
   - 或者使用内存向量库（如 [hnswlib-java](https://github.com/jelmerk/hnswlib)）

3. **优点**
   - ✅ 实现 RAG 功能
   - ✅ 不依赖 Spring 框架
   - ❌ 需要自己实现 AI 调用逻辑

### 方案三：混合方案

**基础功能 + 可选 RAG**：

1. **核心功能**（必须）
   - 代码分析和文档生成
   - 本地文件管理
   - 基础搜索

2. **高级功能**（可选）
   - 配置 Gitee AI 后启用 RAG
   - 配置 Elasticsearch 后启用向量搜索
   - 未配置时降级为基础功能

3. **优点**
   - ✅ 灵活性高
   - ✅ 用户可选
   - ✅ 渐进式实现

---

## 💡 推荐实现路径

### 第一阶段：MVP（最小可行产品）

1. **代码分析器**
   ```java
   public class JavaDocAnalyzer {
       // 使用 PSI API 分析 Spring Boot 项目
       public ProjectDocumentation analyze(Project project) {
           // 扫描 @RestController
           // 提取 @RequestMapping
           // 生成文档模型
       }
   }
   ```

2. **文档生成器**
   ```java
   public class MarkdownGenerator {
       public String generate(ProjectDocumentation doc) {
           // 生成 Markdown 格式
       }
   }
   ```

3. **Action 实现**
   ```java
   public class IndexProjectAction extends AnAction {
       @Override
       public void actionPerformed(@NotNull AnActionEvent e) {
           Project project = e.getProject();
           JavaDocAnalyzer analyzer = new JavaDocAnalyzer();
           ProjectDocumentation doc = analyzer.analyze(project);
           MarkdownGenerator generator = new MarkdownGenerator();
           String markdown = generator.generate(doc);
           // 保存到文件
       }
   }
   ```

### 第二阶段：增强搜索

1. **本地搜索**
   - 使用 Lucene 或简单的文本搜索
   - 不需要向量化

2. **UI 增强**
   - 在工具窗口显示搜索结果
   - 支持跳转到源代码

### 第三阶段：AI 集成（可选）

1. **直接调用 Gitee AI**
   ```java
   public class GiteeAiClient {
       private final String apiKey;
       private final OkHttpClient client;
       
       public String chat(String prompt) {
           // 使用 OkHttp 调用 Gitee AI API
           Request request = new Request.Builder()
               .url("https://ai.gitee.com/v1/chat/completions")
               .header("Authorization", "Bearer " + apiKey)
               .post(...)
               .build();
           Response response = client.newCall(request).execute();
           return parseResponse(response);
       }
   }
   ```

2. **简单的 RAG**
   - 将文档分块存储
   - 查询时找到相关文档
   - 拼接成 prompt 给 AI

---

## 📋 下一步行动

### 立即修复

1. ✅ 添加 Elasticsearch 8.15 依赖
2. ✅ 删除所有 Spring 相关文件
3. ⏳ 修复 `ElasticsearchVectorStore_8_15.java` 编译错误
4. ⏳ 确保项目可以编译通过

### 后续开发

根据您的需求选择：

**选项 A：简化版（快速可用）**
- 只实现代码分析和文档生成
- 1-2 天可完成

**选项 B：完整版（含 RAG）**
- 自己实现 AI 调用
- 需要 1-2 周

**选项 C：暂停活文档功能**
- 专注于插件的其他功能
- 后续再实现

---

## 🔧 当前依赖

```gradle
dependencies {
    // Elasticsearch 8.15
    implementation 'co.elastic.clients:elasticsearch-java:8.15.0'
    implementation 'org.elasticsearch.client:elasticsearch-rest-client:8.15.0'
    implementation 'org.apache.httpcomponents:httpclient:4.5.14'
    implementation 'org.apache.httpcomponents:httpcore:4.4.16'
    
    // HTTP 客户端（AI 调用）
    implementation 'com.squareup.okhttp3:okhttp:4.12.0'
}
```

---

## ❓ 您的选择

请告诉我您希望采用哪个方案：

1. **方案一（简化版）** - 快速实现基础文档功能
2. **方案二（轻量级 RAG）** - 自己实现 AI 调用和 RAG
3. **方案三（混合方案）** - 渐进式实现
4. **暂停活文档功能** - 专注于其他功能

我会根据您的选择继续实现！ 🚀

